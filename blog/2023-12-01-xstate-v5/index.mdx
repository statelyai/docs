---
title: 'XState v5 is here'
description: TODO
authors: [david]
tags: [xstate, stately, state machines, actor model]
date: 2023-12-01
slug: 2023-12-01-xstate-v5
image: /blog/2023-12-01-xstate-v5.png
---

# XState v5 is here

Today, we’re happy to announce XState v5! This is a new major version of XState focusing on actors and helping you get started with XState faster and more easily than previous versions.

State machine transitions take zero time, but transitioning from XState v4 to v5 took a long time. We released XState v4 in October 2018 and have been working on the next major version of XState for most of the years since. With over 25k stars on GitHub, we’ve been able to listen to and learn from those using XState in production and create a version that is more powerful yet simpler (and smaller!) than ever before.

## Our vision for XState v5

In XState v4, **state machines and statecharts were the main focus**. Modeling complex logic in event-driven ways through state machines proved to be a solid strategy for the many companies using XState in production. We learned that XState was not only useful for managing frontend logic, like complex components or multi-step forms, but teams were also using it to manage backend workflows and critical business logic.

But as the use-cases grew, it was clear that XState needed to evolve from managing the logic of one thing to orchestrating the logic of many parts of a system that need to talk to each other. XState originally had **activities**, which were superseded by **invoked actors** (called “services” in v4). State machines and the actor model fit naturally together, as state machines can model the behavior of a single actor, and the actor model can model the behavior of many actors communicating with each other.

So now, in XState v5, **actors are the main focus**. State machines and statecharts are still an important part of XState, but they aren’t the only way you can model an actor’s behavior (although they’re arguably the most robust way). We want XState to be the versatile state orchestration library that enables developers to use the actor model to its full advantage, no matter how they choose to write their logic. Whether you’re writing async logic with promises, using observables, managing state with reducers, or handling any other kind of logic with callback functions, you can use XState to orchestrate your state in an event-driven way.

With that said, we’ve also:

- Greatly simplified the API and reduced the surface area
- Introduced new state machine features that enable powerful patterns
- Massively improved the TypeScript developer experience with better inference
- Reduced the bundle size, by a **lot**
- Revamped the documentation and added many new examples

Let’s take a look at some of my favorite new features.

## Everything is an actor

In XState v5, the **Actor** is the main unit of abstraction. Actors are simpler than you may think; they’re objects that:

- Have their own internal state
- Can send and receive events (or “messages”) and react to them
- Can create other actors

If you’ve worked with libraries like Redux or Zustand, you may think this sounds somewhat like a “store”. And you’d be correct! Just like a store has its own internal state and can change its state when it receives an event, actors can do the that and more.

There are several new actor logic creators in XState v5 for creating:

**Promise actor logic**

```jsx
import { fromPromise } from 'xstate';

const promiseLogic = fromPromise(async ({ input }) => {
  const user = await getUser(input.userId);

  return user;
});
```

**Transition function actor logic**

```jsx
import { fromTransition } from 'xstate';

const transitionLogic = fromTransition((state, event) => {
  switch (event.type) {
    // reducer logic; you know the drill
  }
}, { count: 0 });
```

**Observable actor logic**

```jsx
import { fromObservable } from 'xstate';
import { interval } from 'rxjs';

const intervalLogic = fromObservable(() => interval(1000));
```

**Callback actor logic**

```jsx
import { fromCallback } from 'xstate';

const callbackLogic = fromCallback(({ sendBack, receive }) => {
  const handler = (event) => {
    sendBack(event);
  }
  
	window.addEventListener('message', handler);

	return () => { window.removeEventListener('message', handler); }
});
```

And to create actors from that logic, you use the `createActor(logic)` function:

```jsx
import { createActor } from 'xstate';

// ...

const actor = createActor(someLogic);

actor.subscribe(snapshot => {
  console.log(snapshot);
});

actor.start();

actor.send({ type: 'greet', greeting: 'hello world' });
```

No matter which kind of logic you create, the way you create actors is exactly the same. Actors are a powerful unit of abstraction, since they not only represent a single interface for handling almost anything that can happen in an application, but their communication is also clearly visualized in sequence diagrams (more on that soon).

## Inspect API

There is a new, cleaner way to inspect not only the state transitions of your state machines, but every aspect of actors in an actor system:

- Actor lifecycle
- Actor event communication
- Actor snapshot updates

Instead of magically setting `devTools: true`, the Inspect API lets you attach an “inspector” (just an observer that observes inspection events) to the root of an actor system:

```jsx
const actor = createActor(machine, {
  inspect: (inspectionEvent) => {
		// type: '@xstate.actor' or
		// type: '@xstate.snapshot' or
		// type: '@xstate.event'
		console.log(event);
  }
});
```

The inspector will receive inspection events for every actor in the system, giving you granular visibility into everything that is happening, from how an individual actor is changing to how actors are communicating with each other.

We will soon be releasing inspection devtools that visualize this information as state machine diagrams, sequence diagrams, and more.

## Deep persistence


Actor persistence is a pattern where the internal state of an actor can be persisted and restored at any time. In XState v4, machines can invoke/spawn actors, but those child actors are not persisted. In XState v5 beta, actors are now deeply (recursively) persisted. Invoked/spawned actors will be persisted, as well as actors invoked/spawned from those actors, and so on.

In the following example, the state of the `mainActor` will be persisted, as well as the state of the invoked `someCounter` actor. When the `restoredActor` is started, it will start at the persisted state of `mainActor`, which includes the persisted state of `someCounter`:

```ts
const machine = createMachine({
  invoke: {
    src: 'counter',
    id: 'someCounter',
  },
  // ...
});

const mainActor = interpret(machine);
mainActor.start();

// Deeply persist state
// Also persists the "someCounter" actor!
const persistedState = mainActor.getPersistedState();

// Restore state
const restoredActor = interpret(machine, {
  state: persistedState,
});

// Starts at recursively persisted state
restoredActor.start();
```

This is useful for both client-side (e.g. handling page refreshes) and server-side (e.g. persisting workflow state) use cases. Customizing persistence/restoration logic for actors is also possible, and we will document those options soon.

## Reference actors anywhere

As actors can spawn other actors, which in turn can spawn other actors, these connected actors form a natural hierarchy. This collection of connected actors is known as an actor system.

In XState v5 beta, calling `interpret(...)` to create a root actor will also create an implicit actor system. This enables a key feature called the **receptionist pattern**. The receptionist pattern means actors can be registered and looked up by their `systemId`, which is useful for actors that need to communicate with each other but don’t directly know about each other (i.e., actors not in a parent-child relationship).

For example, let’s say you have a `checkoutMachine` that orchestrates the state of an online shop. If you want a notifier actor to be available to any machines spawned anywhere within the `checkoutMachine` system, you can register it by providing a `systemId`:

```ts
import { notifierMachine } from '../notifierMachine';
import { shippingMachine } from '../shippingMachine';

const checkoutMachine = createMachine({
  invoke: {
    src: notifierMachine,
    systemId: 'notifier',
  },
  // ...
  states: {
    // ...
    shipping: {
      invoke: {
        src: shippingMachine,
      },
    },
  },
});

const checkoutActor = interpret(checkoutMachine);
checkoutActor.start();
```

Now, any actor within the `checkoutActor` system can access the notifier actor by calling `system.get("notifier")`:

```ts
const shippingMachine = createMachine({
  // ...
  on: {
    'address.updated': {
      actions: sendTo(({ system }) => system.get('notifier'), {
        type: 'notify',
        message: 'Shipping address updated',
      }),
    },
  },
});
```

The implicit system and receptionist pattern make it much easier to model arbitrary actor-to-actor communication, event buses, and other event-driven patterns.

## **Input and output**


In some cases where you want to specify initial “input data” for actors. Providing that input data in XState v4 was not easy. You had to either:

- Create a factory machine function that took in some input data and returned a machine with that input data in context.
- Create a new machine with `machine.withContext(...)` and pass the entire context with the input data inside.

Since only the machine should initially determine `context`, this was not ideal, as it was possible to initialize a machine at some impossible state. Additionally, you may want to consider some `context` properties _private_ (internal to the machine) and not externally configurable.

In XState v5 beta, you can now provide input data to machines by passing it as the second argument to `interpret(machine, { input })`. This input data can be read by machines in the `context` initialization function:

```ts
const greetingMachine = createMachine({
  context: ({ input }) => ({
    greeting: `Hello, ${input.name}!`,
  }),
});

const greetingActor = interpret(greetingMachine, {
  input: {
    name: 'David',
  },
});
```

Furthermore, this works for any actor logic, not just state machines:

```ts
const promiseLogic = fromPromise(({ input }) =>
  fetch(`https://api.example.com/users/${input.id}`).then((res) => res.json()),
);

const promiseActor = interpret(promiseLogic, {
  input: {
    id: 42,
  },
});
```

Actors can also have output, which represents their “done data” when they have reached their final state. It’s not just state machines that can have output; promise logic naturally resolves with output, and it may be possible to specify output for other actor logic types in the future.

[TODO: expand]

## Stronger type inference

One of the biggest asks of XState was an improved TypeScript experience. This was no easy feat, given the incidental complexity of statecharts (hierarchical state machines), and the need to represent them in a declarative way so that they could be visualized, statically analyzed, and strongly typed. Any one of these constraints is hard enough; all three proved nearly impossible.

Mateusz Burzyński came to the rescue, not only with incredible feats of TypeScript engineering and wizardry in XState, but also with important contributions made directly to TypeScript itself! The new **setup API** is one area which really highlights the improvements:

```jsx
import { setup, fromPromise } from 'xstate';

const getChatCompletion = fromPromise(async () => { ... });
const processResult = fromPromise(async () => { ... });
const sendToDiscord = fromPromise(async () => { ... });

const machine = setup({
  actors: {
    getChatCompletion,
    processResult,
    sendToDiscord
  }
}).createMachine({
  // ...
  states: {
    thinking: {
      invoke: {
				// string source strongly typed!
				src: 'getChatCompletion',
				onDone: {
					target: 'processing',
					actions: assign({
						// event.output strongly typed!
						completion: ({ event }) => event.output
					})
				}
			}
    },
    processing: {
      invoke: { src: 'processResult', /** ... **/ }
    },
    sending: {
      invoke: { src: 'sendToDiscord', /** ... **/ }
    },
    done: { type: 'final' }
  }
});
```

With `setup(...)`, you no longer need to do the double work of specifying the types of actors, actions, guards, delays, etc. **and** provide them later; just do it in that `setup(...)` function and the types will flow. It’s also much safer since you have the guarantee that those implementations exist, instead of hoping they’ll exist (or relying on typegen) when they’re provided later.

The setup API also enables another magical feature: **strongly-type state values** ✨

[TODO: TS example of strongly-typed state values and state.matches]

## Dynamic parameters

On the theme of type improvements, dynamic action and guard parameters now make it possible to create strongly-typed action and guard implementations that are independent of the state machine:

[TODO: TS example using setup() and dynamic action and guard parameters]

## Enqueue actions

The `enqueueActions()` action creator makes it much easier to coordinate complex actions in a single action creator. Think of it like a more intuitive combination of `pure()` and `choose()`, which are now replaced with this new action creator:

[TODO: enqueueActions() example with enqueue() and check()]

This is a much more natural way of writing effects, since you can use normal JavaScript to construct your effects.

## Self reference


In the unified argument object, there is a `self` property that references the actor itself. This enables new, flexible patterns for actor communication, as you can pass this `self` reference to other actors in events:

```ts
const pingMachine = createMachine({
  invoke: {
    src: 'pong',
    id: 'pong',
  },
  on: {
    ping: {
      actions: sendTo('pong', ({ self }) => ({ type: 'ping', sender: self })),
    },
  },
});

// ...

const pongMachine = createMachine({
  on: {
    ping: {
      actions: sendTo(({ event }) => event.sender, { type: 'pong' }),
    },
  },
});
```

## **Higher-order guards**


In XState v4, guards were simple functions on the `.cond` transition property that returned `true` or `false` to determine if a transition would be taken. To negate a guard or combine guards, you had to create a new guard, which resulted in duplication or redundant code. In XState v5 beta, you can now use higher-order guards, which are functions that take in guards (referenced and/or inline) and return a guard function. There are 3 built-in higher-order guard functions: `and([...guards])`, `or([...guards])`, and `not(guard)`:

```ts
import { createMachine, and, not } from 'xstate';

const userMachine = createMachine(
  {
    // ...
    on: {
      doSomething: {
        // Higher-order guard
        // Renamed from "cond" (v4) -> "guard" (v5)
        guard: and(['isAuthenticated', 'isAdmin', not('isBanned')]),
      },
    },
  },
  {
    guards: {
      isAuthenticated: ({ context }) => context.user !== undefined,
      isAdmin: ({ context }) => context.user.role === 'admin',
      isBanned: ({ context }) => context.user.status === 'banned',
    },
  },
);
```

These higher-order guards can be combined in many different ways to express any complex condition. In the future, Stately visual tooling will be able to visualize complex conditional logic expressed in guards.

## Partial event descriptors


Partial event descriptors, also known as _partial wildcards_, are a powerful new feature in XState v5 beta that makes it easier to handle groups of events. In XState v4, you could use wildcards to handle any event that wasn’t matched by any other transition, but you had to be careful not to handle events that you didn’t intend to handle accidentally. In XState v5 beta, you can use partial event descriptors to handle groups of events by placing a wildcard after the delimiter (`.*`), and you can be explicit about which events you want to handle:

```ts
const machine = createMachine({
  // ...
  on: {
    // Will handle any event that starts with "pointer.":
    // "pointer.down", "pointer.up", "pointer.move", etc.
    'pointer.*': {
      actions: 'logPointerEvent',
    },
  },
});
```

[TODO: mention how they’re now type-safe: magical!]

## Migration and breaking changes

As with any major version, there are some breaking changes. We’ve tried to keep these to a minimum, but some are necessary to make XState v5 beta as powerful and flexible as possible. [Read our current guide for migrating from XState v4 to v5 and the list of breaking changes](https://stately.ai/docs/migration).

The crowd has spoken. Most of you wanted a unified arguments object for all implementation functions. Implementation functions previously took multiple arguments, making it hard to remember which argument to use or awkward to ignore certain arguments. In XState v5 beta, all implementation functions now take a single unified argument object, which contains `context`, `event`, and other properties relevant to the implementation function:

```ts
const machine = createMachine({
  context: {
    count: 0,
  },
  on: {
    increment: {
      // Single argument, instead of:
      // guard: (_, event) => ...
      guard: ({ event }) => !Number.isNaN(event.value),
      // Single argument, instead of:
      // actions: (context, event) => ...
      actions: ({ context, event }) => {
        console.log(context, event);
      },
    },
  },
});
```

## Stately Studio support for v5

- Can already toggle between XState v4 and v5
- Already supports importing from v5
- Input, output, parameters coming soon
- Code editor for actions, actors, guards coming soon (AI-generation feature too)

## Future plans & ideas

- toPromise: [https://github.com/statelyai/xstate/pull/4198](https://github.com/statelyai/xstate/pull/4198)
- Step-based async logic: [https://github.com/statelyai/xstate/pull/4190](https://github.com/statelyai/xstate/pull/4190)
- Routable states: [https://github.com/statelyai/xstate/pull/4184](https://github.com/statelyai/xstate/pull/4184)
- Typestates
