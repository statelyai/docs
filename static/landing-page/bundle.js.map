{
  "version": 3,
  "sources": ["../src/path.ts", "../src/rect.ts", "../src/index.ts"],
  "sourcesContent": ["import type {\n  SidePoint,\n  GridLines,\n  SidePath,\n  LineSegment,\n  GridLine,\n  Point,\n  Ray,\n  Side,\n  SideDirection,\n  XGridLine,\n  YGridLine,\n  SvgPath,\n  SvgPathPortion,\n  CubicCurve,\n  Vector,\n} from './types';\n\nexport const sideFactor: Record<Side, Point & { direction: SideDirection }> = {\n  left: { x: -1, y: 0, direction: 'vertical' },\n  right: { x: 1, y: 0, direction: 'vertical' },\n  top: { x: 0, y: -1, direction: 'horizontal' },\n  bottom: { x: 0, y: 1, direction: 'horizontal' },\n};\n\nexport const oppositeSide: Record<Side, Side> = {\n  left: 'right',\n  right: 'left',\n  top: 'bottom',\n  bottom: 'top',\n};\n\nexport function sidePointToRay(sidePoint: SidePoint): Ray {\n  const ray = {\n    x: sidePoint.x,\n    y: sidePoint.y,\n    dx: sideFactor[sidePoint.side].x,\n    dy: sideFactor[sidePoint.side].y,\n  };\n\n  return ray;\n}\n\nfunction doOrthoRaysIntersect(ray1: Ray, ray2: Ray) {\n  if ((ray1.dx === 0 && ray2.dx === 0) || (ray1.dy === 0 && ray2.dy === 0)) {\n    // parallel; TODO: deal with collinear rays\n    return false;\n  }\n\n  return (\n    ray1.x * ray1.dx <= ray2.x * ray1.dx &&\n    ray1.y * ray1.dy <= ray2.y * ray1.dy &&\n    ray2.x * ray2.dx <= ray1.x * ray2.dx &&\n    ray2.y * ray2.dy <= ray1.y * ray2.dy\n  );\n}\n\nfunction sidePathsMatchDirection(\n  sidePath1: SidePath,\n  sidePathDirections: [SideDirection, SideDirection],\n): boolean {\n  return (\n    sideFactor[sidePath1[0]].direction === sidePathDirections[0] &&\n    sideFactor[sidePath1[1]].direction === sidePathDirections[1]\n  );\n}\n\nexport function getInnerGridLines(\n  sourcePoint: SidePoint,\n  targetPoint: SidePoint,\n  bendRatio: number = 0.5,\n): GridLines {\n  const { side: sourceSide } = sourcePoint;\n  const { side: targetSide } = targetPoint;\n  const sidePath: SidePath = [sourceSide, targetSide];\n  const padding = 20; // TODO: don't hardcode\n\n  const sourceRay = sidePointToRay(sourcePoint);\n  const targetRay = sidePointToRay(targetPoint);\n\n  if (doOrthoRaysIntersect(sourceRay, targetRay)) {\n    return [];\n  }\n\n  if (sidePathsMatchDirection(sidePath, ['vertical', 'horizontal'])) {\n    return [\n      { x: sourcePoint.x + padding * sideFactor[sourceSide].x },\n      { y: targetPoint.y + padding * sideFactor[targetSide].y },\n    ];\n  }\n\n  if (sidePathsMatchDirection(sidePath, ['horizontal', 'vertical'])) {\n    return [\n      { y: sourcePoint.y + padding * sideFactor[sourceSide].y },\n      { x: targetPoint.x + padding * sideFactor[targetSide].x },\n    ];\n  }\n\n  if (sidePathsMatchDirection(sidePath, ['vertical', 'vertical'])) {\n    const xFactor = sideFactor[sourceSide].x;\n\n    if (oppositeSide[sourceSide] === targetSide) {\n      if (xFactor * sourcePoint.x < xFactor * targetPoint.x) {\n        return [\n          { x: sourcePoint.x + (targetPoint.x - sourcePoint.x) * bendRatio },\n        ];\n      } else {\n        return [\n          { x: sourcePoint.x + padding * xFactor },\n          { y: sourcePoint.y + (targetPoint.y - sourcePoint.y) * bendRatio },\n          { x: targetPoint.x + padding * sideFactor[targetSide].x },\n        ];\n      }\n    }\n\n    return [\n      {\n        x:\n          xFactor * Math.max(xFactor * sourcePoint.x, xFactor * targetPoint.x) +\n          padding * xFactor,\n      },\n    ];\n  }\n\n  if (sidePathsMatchDirection(sidePath, ['horizontal', 'horizontal'])) {\n    const yFactor = sideFactor[sourceSide].y;\n\n    if (oppositeSide[sourceSide] === targetSide) {\n      if (yFactor * sourcePoint.y < yFactor * targetPoint.y) {\n        return [\n          { y: sourcePoint.y + (targetPoint.y - sourcePoint.y) * bendRatio },\n        ];\n      } else {\n        return [\n          { y: sourcePoint.y + padding * yFactor },\n          { x: sourcePoint.x + (targetPoint.x - sourcePoint.x) * bendRatio },\n          { y: targetPoint.y + padding * sideFactor[targetSide].y },\n        ];\n      }\n    }\n\n    return [\n      {\n        y:\n          yFactor * Math.max(yFactor * sourcePoint.y, yFactor * targetPoint.y) +\n          padding * yFactor,\n      },\n    ];\n  }\n  return [];\n}\n\nexport function getLineSegmentsFromGridLines(\n  sourcePoint: SidePoint,\n  targetPoint: SidePoint,\n  gridLines: GridLine[],\n): {\n  sourceLineSegment: LineSegment;\n  lineSegments: LineSegment[];\n  targetLineSegment: LineSegment;\n  allLineSegments: LineSegment[];\n} {\n  const allGridLines = [\n    ['top', 'bottom'].includes(sourcePoint.side)\n      ? { x: sourcePoint.x }\n      : { y: sourcePoint.y },\n    ...gridLines,\n    ['top', 'bottom'].includes(targetPoint.side)\n      ? { x: targetPoint.x }\n      : { y: targetPoint.y },\n  ];\n\n  const pointToLine = <T extends GridLine>(\n    point: Point,\n    line: T,\n    nextLine: T extends XGridLine ? YGridLine : XGridLine,\n  ): LineSegment => {\n    const lineVertical = 'x' in line;\n\n    return [\n      point,\n      lineVertical\n        ? { x: line.x, y: (nextLine as YGridLine).y }\n        : { x: (nextLine as XGridLine).x, y: line.y },\n    ];\n  };\n\n  let currentPoint =\n    'x' in allGridLines[0]\n      ? { x: allGridLines[0].x, y: sourcePoint.y }\n      : { x: sourcePoint.x, y: allGridLines[0].y };\n  const segments: LineSegment[] = [];\n\n  for (let i = 0; i < allGridLines.length; i++) {\n    const line = allGridLines[i];\n    const nextLine =\n      allGridLines[i + 1] ??\n      ('x' in line ? { y: targetPoint.y } : { x: targetPoint.x });\n    const nextSegment = pointToLine(currentPoint, line, nextLine);\n    segments.push(nextSegment);\n    currentPoint = nextSegment[1];\n  }\n\n  return {\n    sourceLineSegment: segments[0],\n    lineSegments: segments.slice(1, -1),\n    targetLineSegment: segments[segments.length - 1],\n    allLineSegments: segments,\n  };\n}\n\nexport function getSvgPathFromSegments(\n  segments: LineSegment[],\n  sourcePoint: SidePoint,\n  targetPoint: SidePoint,\n  padding: number = 10,\n): SvgPath {\n  // @ts-ignore\n  const path: SvgPath = [];\n\n  segments.forEach((segment, i) => {\n    if (!path.length) {\n      path.push(['M', segment[0]]);\n    }\n\n    // if last segment\n    if (i === segments.length - 1) {\n      const preEndPoint = { ...segment[1] };\n      switch (targetPoint.side) {\n        case 'left':\n          preEndPoint.x -= padding;\n          break;\n        case 'right':\n          preEndPoint.x += padding;\n          break;\n        case 'top':\n          preEndPoint.y -= padding;\n          break;\n        case 'bottom':\n          preEndPoint.y += padding;\n          break;\n        default:\n          break;\n      }\n      path.push(['L', preEndPoint]);\n    } else {\n      path.push(['L', segment[1]]);\n    }\n  });\n\n  return path;\n}\n\nexport function pathToD(path: SvgPath): string {\n  return path\n    .map(([cmd, ...points]) =>\n      [\n        cmd,\n        ...points.map((point: Point | number) => {\n          if (typeof point === 'number') {\n            return point;\n          }\n          return `${point.x},${point.y}`;\n        }),\n      ].join(' '),\n    )\n    .join(' ');\n}\n\nexport function bendPath(path: SvgPath, radius: number): SvgPath {\n  const contiguousLinePaths: SvgPathPortion[] = [];\n  const bentPath = [] as unknown as SvgPath;\n  const current: SvgPathPortion = [];\n\n  for (const svgPoint of path) {\n    const [cmd] = svgPoint;\n    if (!['L', 'H', 'V'].includes(cmd)) {\n      if (current.length > 1) {\n        contiguousLinePaths.push([...current]);\n        current.length = 0;\n      }\n    }\n\n    current.push(svgPoint);\n  }\n  if (current.length > 1) {\n    contiguousLinePaths.push([...current]);\n  }\n\n  for (const linePath of contiguousLinePaths) {\n    const points = linePath.map(([, point]) => point as Point); // TODO: fix\n    const pointsWithMid = withMidpoints(simplifyPoints(points));\n\n    const bentPathPortion: SvgPath = [linePath[0] as any /* TODO */];\n\n    pointsWithMid.forEach((pt, i, pts) => {\n      if (\n        i >= 2 &&\n        i <= pts.length - 2 &&\n        isBendable(pts[i - 1], pt, pts[i + 1])\n      ) {\n        const { p1, p2, p } = roundOneCorner(\n          pts[i - 1],\n          pt,\n          pts[i + 1],\n          radius,\n        );\n\n        bentPathPortion.push(['L', p1], ['C', p1, p, p2]);\n      } else if (i > 0) {\n        bentPathPortion.push(['L', pt]);\n      }\n    });\n\n    bentPath.push(...bentPathPortion);\n  }\n\n  return bentPath;\n}\n\nexport function withMidpoints(points: Point[]): Point[] {\n  const pointsWithMid: Point[] = [];\n\n  points.forEach((pt, i) => {\n    const [ptA, ptB, ptC] = [pt, points[i + 1], points[i + 2]];\n\n    if (!ptC || !ptB) {\n      pointsWithMid.push(ptA);\n      return;\n    }\n\n    const midpt = {\n      x: ptA.x + (ptB.x - ptA.x) / 2,\n      y: ptA.y + (ptB.y - ptA.y) / 2,\n    };\n\n    pointsWithMid.push(ptA, midpt);\n  });\n\n  return pointsWithMid;\n}\n\nexport function simplifyPoints(points: Point[]): Point[] {\n  const pointHashes = new Set<string>();\n\n  const result: Point[] = [];\n\n  points.forEach((point, i) => {\n    const prevPoint = points[i - 1];\n    const nextPoint = points[i + 1];\n\n    if (prevPoint?.x === point.x && point.x === nextPoint?.x) {\n      return;\n    }\n    if (prevPoint?.y === point.y && point.y === nextPoint?.y) {\n      return;\n    }\n\n    const hash = `${point.x}|${point.y}`;\n\n    if (pointHashes.has(hash)) {\n      return;\n    }\n\n    result.push(point);\n  });\n\n  return result;\n}\n\nconst lineToVector = (p1: Point, p2: Point): Vector => {\n  const vector = {\n    type: 'vector' as const,\n    x: p2.x - p1.x,\n    y: p2.y - p1.y,\n  };\n\n  return vector;\n};\n\nconst vectorToUnitVector = (v: Vector): Vector => {\n  let magnitude = v.x * v.x + v.y * v.y;\n  magnitude = Math.sqrt(magnitude);\n  const unitVector = {\n    type: 'vector' as const,\n    x: v.x / magnitude,\n    y: v.y / magnitude,\n  };\n  return unitVector;\n};\n\nexport const roundOneCorner = (\n  p1: Point,\n  corner: Point,\n  p2: Point,\n  radius: number,\n): CubicCurve => {\n  const corner_to_p1 = lineToVector(corner, p1);\n  const corner_to_p2 = lineToVector(corner, p2);\n  const p1dist = Math.hypot(corner_to_p1.x, corner_to_p1.y);\n  const p2dist = Math.hypot(corner_to_p2.x, corner_to_p2.y);\n  if (p1dist * p2dist === 0) {\n    return {\n      p1: corner,\n      p2: corner,\n      p: corner,\n    };\n  }\n  const resolvedRadius = Math.min(radius, p1dist - 0.1, p2dist - 0.1);\n  const corner_to_p1_unit = vectorToUnitVector(corner_to_p1);\n  const corner_to_p2_unit = vectorToUnitVector(corner_to_p2);\n\n  const curve_p1 = {\n    x: corner.x + corner_to_p1_unit.x * resolvedRadius,\n    y: corner.y + corner_to_p1_unit.y * resolvedRadius,\n  };\n  const curve_p2 = {\n    x: corner.x + corner_to_p2_unit.x * resolvedRadius,\n    y: corner.y + corner_to_p2_unit.y * resolvedRadius,\n  };\n  const path = {\n    p1: curve_p1,\n    p2: curve_p2,\n    p: corner,\n  };\n\n  return path;\n};\n\nexport function isBendable(p1: Point, corner: Point, p2: Point): boolean {\n  return !(\n    (p1.x === corner.x && p2.x === corner.x) ||\n    (p1.y === corner.y && p2.y === corner.y)\n  );\n}\n\n// ......\n", "import {\n  LineSegment,\n  RectInit,\n  SidePoint,\n  RelativeSidePoint,\n  Side,\n} from './types';\n\nexport interface Point {\n  [key: string]: any;\n  x: number;\n  y: number;\n}\n\nexport type PartialRect =\n  | (({ left: number } | { right: number }) &\n      ({ top: number } | { bottom: number }) & {\n        width: number;\n        height: number;\n      })\n  | { left: number; right: number; top: number; bottom: number };\n\n/**\n * A box is represented by two corner points\n */\nexport type Box = [Point, Point];\n\nexport class Rect implements DOMRect {\n  public top: number;\n  public left: number;\n  public bottom: number;\n  public right: number;\n  public width: number;\n  public height: number;\n  public x: number;\n  public y: number;\n\n  public toJSON() {\n    const { top, left, bottom, right, width, height, x, y } = this;\n    return { top, left, bottom, right, width, height, x, y };\n  }\n\n  constructor(box: Box);\n  constructor(rect: RectInit | PartialRect);\n  constructor(rect: Box | RectInit | PartialRect) {\n    if (Array.isArray(rect)) {\n      const minX = Math.min(rect[0].x, rect[1].x);\n      const width = Math.max(rect[0].x, rect[1].x) - minX;\n      const minY = Math.min(rect[0].y, rect[1].y);\n      const height = Math.max(rect[0].y, rect[1].y) - minY;\n      this.top = minY;\n      this.left = minX;\n      this.width = width;\n      this.right = this.left + this.width;\n      this.height = height;\n      this.bottom = this.top + this.height;\n      this.x = this.left;\n      this.y = this.top;\n    } else {\n      this.top =\n        'top' in rect\n          ? rect.top\n          : 'y' in rect\n          ? rect.y\n          : rect.bottom - rect.height;\n      this.left =\n        'left' in rect\n          ? rect.left\n          : 'x' in rect\n          ? rect.x\n          : rect.right - rect.width;\n      this.bottom = 'bottom' in rect ? rect.bottom : this.top + rect.height;\n      this.right = 'right' in rect ? rect.right : this.left + rect.width;\n      this.width = this.right - this.left;\n      this.height = this.bottom - this.top;\n      this.x = this.left;\n      this.y = this.top;\n    }\n  }\n\n  public point(x: string, y: string, meta?: Record<string, any>): Point {\n    const point: Point = { x: 0, y: 0, ...meta };\n\n    switch (x) {\n      case 'left':\n        point.x = this.left;\n        break;\n      case 'right':\n        point.x = this.right;\n        break;\n\n      case 'center':\n        point.x = this.left + this.width / 2;\n        break;\n      default:\n        break;\n    }\n    switch (y) {\n      case 'top':\n        point.y = this.top;\n        break;\n      case 'bottom':\n        point.y = this.bottom;\n        break;\n\n      case 'center':\n        point.y = this.top + this.height / 2;\n        break;\n      default:\n        break;\n    }\n\n    return point;\n  }\n\n  public get center(): Point {\n    return {\n      x: this.left + this.width / 2,\n      y: this.top + this.height / 2,\n    };\n  }\n\n  public centerSide(side: Side, offset: number = 0): SidePoint {\n    switch (side) {\n      case 'left':\n        return { side: 'left', x: this.left - offset, y: this.center.y };\n      case 'right':\n        return { side: 'right', x: this.right + offset, y: this.center.y };\n      case 'top':\n        return { side: 'top', x: this.center.x, y: this.top - offset };\n      case 'bottom':\n        return { side: 'bottom', x: this.center.x, y: this.bottom + offset };\n    }\n  }\n\n  public relativeSide(side: Side, percent: number): SidePoint {\n    switch (side) {\n      case 'left':\n      case 'right':\n        return { side, x: this[side], y: this.y + this.height * percent };\n      case 'top':\n      case 'bottom':\n        return { side, x: this.x + this.width * percent, y: this[side] };\n    }\n  }\n\n  public getRelativeSidePoint(sidePoint: SidePoint): RelativeSidePoint {\n    const { side } = sidePoint;\n    switch (side) {\n      case 'left':\n      case 'right': {\n        const percent =\n          this.height === 0 ? 0.5 : (sidePoint.y - this.y) / this.height;\n        return { side, percent };\n      }\n      case 'top':\n      case 'bottom': {\n        const percent =\n          this.width === 0 ? 0.5 : (sidePoint.x - this.x) / this.width;\n\n        return { side, percent };\n      }\n    }\n  }\n\n  public sideSegment(side: Side): LineSegment {\n    switch (side) {\n      case 'left':\n        return [\n          { x: this.left, y: this.top },\n          { x: this.left, y: this.bottom },\n        ];\n      case 'right':\n        return [\n          { x: this.right, y: this.top },\n          { x: this.right, y: this.bottom },\n        ];\n      case 'top':\n        return [\n          { x: this.left, y: this.top },\n          { x: this.right, y: this.top },\n        ];\n      case 'bottom':\n        return [\n          { x: this.left, y: this.bottom },\n          { x: this.right, y: this.bottom },\n        ];\n      default:\n        throw new Error('Invalid side');\n    }\n  }\n\n  public equals(otherRect: DOMRect): boolean {\n    return [\n      'top' as const,\n      'left' as const,\n      'bottom' as const,\n      'right' as const,\n    ].every((prop) => {\n      return otherRect[prop] === this[prop];\n    });\n  }\n\n  public translate(dx: number, dy: number): Rect {\n    return new Rect({\n      left: this.left + dx,\n      top: this.top + dy,\n      width: this.width,\n      height: this.height,\n    });\n  }\n\n  public moveTo(point: Point): Rect {\n    return new Rect({\n      left: point.x,\n      top: point.y,\n      width: this.width,\n      height: this.height,\n    });\n  }\n\n  public withPadding(horizontal: number, vertical: number = horizontal): Rect {\n    return new Rect({\n      left: this.left - horizontal,\n      right: this.right + horizontal,\n      top: this.top - vertical,\n      bottom: this.bottom + vertical,\n    });\n  }\n\n  public getBox(): Box {\n    return [\n      { x: this.left, y: this.top },\n      { x: this.right, y: this.bottom },\n    ];\n  }\n}\n\nexport function fromPoint(point: Point, width: number, height: number): Rect {\n  return new Rect({\n    left: point.x,\n    top: point.y,\n    width,\n    height,\n    bottom: point.y + height,\n    right: point.x + width,\n  });\n}\n\nexport function rectFrom(domRect: DOMRect): Rect {\n  return new Rect(domRect);\n}\n\nexport function relative(childRect: Rect, parentRect?: Rect): Rect {\n  if (!parentRect) {\n    return childRect;\n  }\n\n  return new Rect({\n    top: childRect.top - parentRect.top,\n    right: childRect.right - parentRect.left,\n    bottom: childRect.bottom - parentRect.top,\n    left: childRect.left - parentRect.left,\n    width: childRect.width,\n    height: childRect.height,\n  });\n}\n\nexport function pointOnSide(\n  rect: Rect,\n  side: Side,\n  percent: number,\n): SidePoint {\n  let segment: LineSegment;\n  let xFactor = 0,\n    yFactor = 0;\n\n  switch (side) {\n    case 'left':\n      segment = [\n        { x: rect.left, y: rect.top },\n        { x: rect.left, y: rect.bottom },\n      ];\n      yFactor = percent;\n      break;\n    case 'right':\n      segment = [\n        { x: rect.right, y: rect.top },\n        { x: rect.right, y: rect.bottom },\n      ];\n      yFactor = percent;\n      break;\n    case 'top':\n      segment = [\n        { x: rect.left, y: rect.top },\n        { x: rect.right, y: rect.top },\n      ];\n      xFactor = percent;\n      break;\n    case 'bottom':\n      segment = [\n        { x: rect.left, y: rect.bottom },\n        { x: rect.right, y: rect.bottom },\n      ];\n      xFactor = percent;\n      break;\n    default:\n      throw new Error(`Invalid side: ${side}`);\n  }\n\n  return {\n    x: (segment[1].x - segment[0].x) * xFactor + segment[0].x,\n    y: (segment[1].y - segment[0].y) * yFactor + segment[0].y,\n    side,\n  };\n}\n", "import {\n  getInnerGridLines,\n  getLineSegmentsFromGridLines,\n  getSvgPathFromSegments,\n  pathToD,\n  bendPath,\n  oppositeSide,\n} from './path';\nimport { Rect } from './rect';\nimport { Side } from './types';\n\nconst svgEl = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n\nsvgEl.setAttribute(\n  'style',\n  `\nposition: absolute;\ntop: 0;\nleft: 0;\nwidth: 100vw;\nheight: 100vh;\nmax-width: 100%;\noverflow: visible;\npointer-events: none;\nz-index: 2;\n`,\n);\n\nconst defEl = document.createElementNS('http://www.w3.org/2000/svg', 'defs');\n\ndefEl.innerHTML = `\n<marker\n  id=\"arrow\"\n  viewBox=\"0 0 10 10\"\n  markerWidth=\"5\"\n  markerHeight=\"5\"\n  refX=\"0\"\n  refY=\"5\"\n  markerUnits=\"strokeWidth\"\n  orient=\"auto\"\n>\n  <path data-arrow=\"marker\" d=\"M0,0 L0,10 L10,5 z\" fill=\"currentcolor\" />\n</marker>\n`;\nsvgEl.appendChild(defEl);\ndocument.body.appendChild(svgEl);\n\ninterface DrawnPath {\n  redraw: () => void;\n}\n\nfunction onResize(el: any, cb: (rect: Rect) => void) {\n  const resizeObserver = new ResizeObserver(() => {\n    requestAnimationFrame(() => {\n      if (el.ownerDocument.contains(el)) {\n        cb(el.getBoundingClientRect());\n      }\n    });\n  });\n  resizeObserver.observe(el);\n\n  return () => resizeObserver.unobserve(el);\n}\n\nfunction drawPath(config: {\n  source: Element;\n  sourceSide: Side;\n  /**\n   * Distance (%) from left or top of source side.\n   *\n   * @default 0.5\n   */\n  sourcePosition?: number;\n  target: Element;\n  targetSide: Side;\n  /**\n   * Distance (%) from left or top of target side.\n   *\n   * @default 0.5\n   */\n  targetPosition?: number;\n  /**\n   * Distance (%) between start and end of zig-zag edge where it\n   * should cut across.\n   *\n   * @default 0.5\n   */\n  bendPosition?: number;\n  radius?: number;\n  color?: string;\n  attributes?: Record<string, string>;\n}): DrawnPath {\n  const resolvedConfig = {\n    radius: 10,\n    ...config,\n  };\n\n  const { source, target } = resolvedConfig;\n\n  function getPathD() {\n    const svgRect = new Rect(svgEl.getBoundingClientRect());\n\n    const sourceRect = new Rect(source.getBoundingClientRect());\n    const targetRect = new Rect(target.getBoundingClientRect());\n    const startPoint = sourceRect.relativeSide(\n      resolvedConfig.sourceSide,\n      resolvedConfig.sourcePosition ?? 0.5,\n    );\n    let endPoint = targetRect.relativeSide(\n      resolvedConfig.targetSide,\n      resolvedConfig.targetPosition ?? 0.5,\n    );\n\n    if (\n      oppositeSide[resolvedConfig.sourceSide] === resolvedConfig.targetSide &&\n      resolvedConfig.targetPosition === undefined\n    ) {\n      if (\n        ['top', 'bottom'].includes(resolvedConfig.targetSide) &&\n        startPoint.x > targetRect.left &&\n        startPoint.x < targetRect.right\n      ) {\n        endPoint.x = startPoint.x;\n      } else if (\n        startPoint.y > targetRect.top &&\n        startPoint.y < targetRect.bottom\n      ) {\n        endPoint.y = startPoint.y;\n      }\n    }\n    startPoint.y -= svgRect.top;\n    endPoint.y -= svgRect.top;\n    const lines = getInnerGridLines(\n      startPoint,\n      endPoint,\n      resolvedConfig.bendPosition ?? 0.5,\n    );\n    const lineSegments = getLineSegmentsFromGridLines(\n      startPoint,\n      endPoint,\n      lines,\n    );\n\n    const svgPath = getSvgPathFromSegments(\n      lineSegments.allLineSegments,\n      startPoint,\n      endPoint,\n    );\n\n    const pathD = pathToD(bendPath(svgPath, resolvedConfig.radius));\n\n    return pathD;\n  }\n\n  const pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n\n  pathEl.setAttribute('stroke', resolvedConfig.color ?? 'white');\n  pathEl.setAttribute('stroke-width', '2');\n  pathEl.setAttribute('fill', 'none');\n  pathEl.setAttribute('d', getPathD());\n  pathEl.setAttribute('marker-end', 'url(#arrow)');\n\n  if (resolvedConfig.attributes) {\n    Object.entries(resolvedConfig.attributes).forEach(([key, value]) => {\n      pathEl.setAttribute(key, value);\n    });\n  }\n  svgEl.appendChild(pathEl);\n\n  const obj = {\n    redraw: () => {\n      pathEl.setAttribute('d', getPathD());\n    },\n  };\n\n  onResize(source, obj.redraw);\n  onResize(target, obj.redraw);\n\n  return obj;\n}\n\nfunction maybeStringToNumber(string?: string): number | undefined {\n  return string !== undefined ? +string : undefined;\n}\n\nconst nodeEls = document.querySelectorAll<HTMLElement>('[data-edge-source]');\nconst paths: DrawnPath[] = [];\n\nnodeEls.forEach((elNode) => {\n  const target = elNode.dataset.edgeTarget;\n\n  if (!target) {\n    return;\n  }\n\n  const elTarget = document.querySelector(`[data-edge-source=\"${target}\"]`);\n\n  if (!elTarget) {\n    return;\n  }\n\n  const sourceSide = (elNode.dataset.edgeSourceSide as Side) ?? 'bottom';\n  const targetSide = (elNode.dataset.edgeTargetSide as Side) ?? 'top';\n  const sourcePosition = maybeStringToNumber(elNode.dataset.edgeSourcePosition);\n  const targetPosition = maybeStringToNumber(elNode.dataset.edgeTargetPosition);\n  const bendPosition = maybeStringToNumber(elNode.dataset.edgeBendPosition);\n\n  paths.push(\n    drawPath({\n      source: elNode,\n      sourceSide,\n      sourcePosition,\n      target: elTarget,\n      targetSide,\n      targetPosition,\n      bendPosition,\n      attributes: {\n        class: 'edge',\n      },\n      radius: 20,\n    }),\n  );\n});\n\nwindow.addEventListener('resize', () => {\n  paths.forEach((path) => path.redraw());\n});\n\nonResize(document.body, () => {\n  paths.forEach((path) => path.redraw());\n});\n"],
  "mappings": "+VAkBO,GAAM,GAAiE,CAC5E,KAAM,CAAE,EAAG,GAAI,EAAG,EAAG,UAAW,YAChC,MAAO,CAAE,EAAG,EAAG,EAAG,EAAG,UAAW,YAChC,IAAK,CAAE,EAAG,EAAG,EAAG,GAAI,UAAW,cAC/B,OAAQ,CAAE,EAAG,EAAG,EAAG,EAAG,UAAW,eAGtB,EAAmC,CAC9C,KAAM,QACN,MAAO,OACP,IAAK,SACL,OAAQ,OAGH,WAAwB,EAA2B,CAQxD,MAPY,CACV,EAAG,EAAU,EACb,EAAG,EAAU,EACb,GAAI,EAAW,EAAU,MAAM,EAC/B,GAAI,EAAW,EAAU,MAAM,GAMnC,WAA8B,EAAW,EAAW,CAClD,MAAK,GAAK,KAAO,GAAK,EAAK,KAAO,GAAO,EAAK,KAAO,GAAK,EAAK,KAAO,EAE7D,GAIP,EAAK,EAAI,EAAK,IAAM,EAAK,EAAI,EAAK,IAClC,EAAK,EAAI,EAAK,IAAM,EAAK,EAAI,EAAK,IAClC,EAAK,EAAI,EAAK,IAAM,EAAK,EAAI,EAAK,IAClC,EAAK,EAAI,EAAK,IAAM,EAAK,EAAI,EAAK,GAItC,WACE,EACA,EACS,CACT,MACE,GAAW,EAAU,IAAI,YAAc,EAAmB,IAC1D,EAAW,EAAU,IAAI,YAAc,EAAmB,GAIvD,WACL,EACA,EACA,EAAoB,GACT,CACX,GAAM,CAAE,KAAM,GAAe,EACvB,CAAE,KAAM,GAAe,EACvB,EAAqB,CAAC,EAAY,GAClC,EAAU,GAEV,EAAY,EAAe,GAC3B,EAAY,EAAe,GAEjC,GAAI,EAAqB,EAAW,GAClC,MAAO,GAGT,GAAI,EAAwB,EAAU,CAAC,WAAY,eACjD,MAAO,CACL,CAAE,EAAG,EAAY,EAAI,EAAU,EAAW,GAAY,GACtD,CAAE,EAAG,EAAY,EAAI,EAAU,EAAW,GAAY,IAI1D,GAAI,EAAwB,EAAU,CAAC,aAAc,aACnD,MAAO,CACL,CAAE,EAAG,EAAY,EAAI,EAAU,EAAW,GAAY,GACtD,CAAE,EAAG,EAAY,EAAI,EAAU,EAAW,GAAY,IAI1D,GAAI,EAAwB,EAAU,CAAC,WAAY,aAAc,CAC/D,GAAM,GAAU,EAAW,GAAY,EAEvC,MAAI,GAAa,KAAgB,EAC3B,EAAU,EAAY,EAAI,EAAU,EAAY,EAC3C,CACL,CAAE,EAAG,EAAY,EAAK,GAAY,EAAI,EAAY,GAAK,IAGlD,CACL,CAAE,EAAG,EAAY,EAAI,EAAU,GAC/B,CAAE,EAAG,EAAY,EAAK,GAAY,EAAI,EAAY,GAAK,GACvD,CAAE,EAAG,EAAY,EAAI,EAAU,EAAW,GAAY,IAKrD,CACL,CACE,EACE,EAAU,KAAK,IAAI,EAAU,EAAY,EAAG,EAAU,EAAY,GAClE,EAAU,IAKlB,GAAI,EAAwB,EAAU,CAAC,aAAc,eAAgB,CACnE,GAAM,GAAU,EAAW,GAAY,EAEvC,MAAI,GAAa,KAAgB,EAC3B,EAAU,EAAY,EAAI,EAAU,EAAY,EAC3C,CACL,CAAE,EAAG,EAAY,EAAK,GAAY,EAAI,EAAY,GAAK,IAGlD,CACL,CAAE,EAAG,EAAY,EAAI,EAAU,GAC/B,CAAE,EAAG,EAAY,EAAK,GAAY,EAAI,EAAY,GAAK,GACvD,CAAE,EAAG,EAAY,EAAI,EAAU,EAAW,GAAY,IAKrD,CACL,CACE,EACE,EAAU,KAAK,IAAI,EAAU,EAAY,EAAG,EAAU,EAAY,GAClE,EAAU,IAIlB,MAAO,GAGF,WACL,EACA,EACA,EAMA,CAjKF,MAkKE,GAAM,GAAe,CACnB,CAAC,MAAO,UAAU,SAAS,EAAY,MACnC,CAAE,EAAG,EAAY,GACjB,CAAE,EAAG,EAAY,GACrB,GAAG,EACH,CAAC,MAAO,UAAU,SAAS,EAAY,MACnC,CAAE,EAAG,EAAY,GACjB,CAAE,EAAG,EAAY,IAGjB,EAAc,CAClB,EACA,EACA,IACgB,CAChB,GAAM,GAAe,KAAO,GAE5B,MAAO,CACL,EACA,EACI,CAAE,EAAG,EAAK,EAAG,EAAI,EAAuB,GACxC,CAAE,EAAI,EAAuB,EAAG,EAAG,EAAK,KAI5C,EACF,KAAO,GAAa,GAChB,CAAE,EAAG,EAAa,GAAG,EAAG,EAAG,EAAY,GACvC,CAAE,EAAG,EAAY,EAAG,EAAG,EAAa,GAAG,GACvC,EAA0B,GAEhC,OAAS,GAAI,EAAG,EAAI,EAAa,OAAQ,IAAK,CAC5C,GAAM,GAAO,EAAa,GACpB,EACJ,KAAa,EAAI,KAAjB,OACC,KAAO,GAAO,CAAE,EAAG,EAAY,GAAM,CAAE,EAAG,EAAY,GACnD,EAAc,EAAY,EAAc,EAAM,GACpD,EAAS,KAAK,GACd,EAAe,EAAY,GAG7B,MAAO,CACL,kBAAmB,EAAS,GAC5B,aAAc,EAAS,MAAM,EAAG,IAChC,kBAAmB,EAAS,EAAS,OAAS,GAC9C,gBAAiB,GAId,WACL,EACA,EACA,EACA,EAAkB,GACT,CAET,GAAM,GAAgB,GAEtB,SAAS,QAAQ,CAAC,EAAS,IAAM,CAM/B,GALK,EAAK,QACR,EAAK,KAAK,CAAC,IAAK,EAAQ,KAItB,IAAM,EAAS,OAAS,EAAG,CAC7B,GAAM,GAAc,KAAK,EAAQ,IACjC,OAAQ,EAAY,UACb,OACH,EAAY,GAAK,EACjB,UACG,QACH,EAAY,GAAK,EACjB,UACG,MACH,EAAY,GAAK,EACjB,UACG,SACH,EAAY,GAAK,EACjB,cAEA,MAEJ,EAAK,KAAK,CAAC,IAAK,QAEhB,GAAK,KAAK,CAAC,IAAK,EAAQ,OAIrB,EAGF,WAAiB,EAAuB,CAC7C,MAAO,GACJ,IAAI,CAAC,CAAC,KAAQ,KACb,CACE,EACA,GAAG,EAAO,IAAI,AAAC,GACT,MAAO,IAAU,SACZ,EAEF,GAAG,EAAM,KAAK,EAAM,MAE7B,KAAK,MAER,KAAK,KAGH,WAAkB,EAAe,EAAyB,CAC/D,GAAM,GAAwC,GACxC,EAAW,GACX,EAA0B,GAEhC,OAAW,KAAY,GAAM,CAC3B,GAAM,CAAC,GAAO,EACd,AAAK,CAAC,IAAK,IAAK,KAAK,SAAS,IACxB,EAAQ,OAAS,GACnB,GAAoB,KAAK,CAAC,GAAG,IAC7B,EAAQ,OAAS,GAIrB,EAAQ,KAAK,GAEf,AAAI,EAAQ,OAAS,GACnB,EAAoB,KAAK,CAAC,GAAG,IAG/B,OAAW,KAAY,GAAqB,CAC1C,GAAM,GAAS,EAAS,IAAI,CAAC,CAAC,CAAE,KAAW,GACrC,EAAgB,EAAc,EAAe,IAE7C,EAA2B,CAAC,EAAS,IAE3C,EAAc,QAAQ,CAAC,EAAI,EAAG,IAAQ,CACpC,GACE,GAAK,GACL,GAAK,EAAI,OAAS,GAClB,EAAW,EAAI,EAAI,GAAI,EAAI,EAAI,EAAI,IACnC,CACA,GAAM,CAAE,KAAI,KAAI,KAAM,EACpB,EAAI,EAAI,GACR,EACA,EAAI,EAAI,GACR,GAGF,EAAgB,KAAK,CAAC,IAAK,GAAK,CAAC,IAAK,EAAI,EAAG,QACxC,AAAI,GAAI,GACb,EAAgB,KAAK,CAAC,IAAK,MAI/B,EAAS,KAAK,GAAG,GAGnB,MAAO,GAGF,WAAuB,EAA0B,CACtD,GAAM,GAAyB,GAE/B,SAAO,QAAQ,CAAC,EAAI,IAAM,CACxB,GAAM,CAAC,EAAK,EAAK,GAAO,CAAC,EAAI,EAAO,EAAI,GAAI,EAAO,EAAI,IAEvD,GAAI,CAAC,GAAO,CAAC,EAAK,CAChB,EAAc,KAAK,GACnB,OAGF,GAAM,GAAQ,CACZ,EAAG,EAAI,EAAK,GAAI,EAAI,EAAI,GAAK,EAC7B,EAAG,EAAI,EAAK,GAAI,EAAI,EAAI,GAAK,GAG/B,EAAc,KAAK,EAAK,KAGnB,EAGF,WAAwB,EAA0B,CACvD,GAAM,GAAc,GAAI,KAElB,EAAkB,GAExB,SAAO,QAAQ,CAAC,EAAO,IAAM,CAC3B,GAAM,GAAY,EAAO,EAAI,GACvB,EAAY,EAAO,EAAI,GAK7B,GAHI,kBAAW,KAAM,EAAM,GAAK,EAAM,IAAM,kBAAW,IAGnD,kBAAW,KAAM,EAAM,GAAK,EAAM,IAAM,kBAAW,GACrD,OAGF,GAAM,GAAO,GAAG,EAAM,KAAK,EAAM,IAEjC,AAAI,EAAY,IAAI,IAIpB,EAAO,KAAK,KAGP,EAGT,GAAM,GAAe,CAAC,EAAW,IAChB,EACb,KAAM,SACN,EAAG,EAAG,EAAI,EAAG,EACb,EAAG,EAAG,EAAI,EAAG,IAMX,EAAqB,AAAC,GAAsB,CAChD,GAAI,GAAY,EAAE,EAAI,EAAE,EAAI,EAAE,EAAI,EAAE,EACpC,SAAY,KAAK,KAAK,GACH,CACjB,KAAM,SACN,EAAG,EAAE,EAAI,EACT,EAAG,EAAE,EAAI,IAKA,EAAiB,CAC5B,EACA,EACA,EACA,IACe,CACf,GAAM,GAAe,EAAa,EAAQ,GACpC,EAAe,EAAa,EAAQ,GACpC,EAAS,KAAK,MAAM,EAAa,EAAG,EAAa,GACjD,EAAS,KAAK,MAAM,EAAa,EAAG,EAAa,GACvD,GAAI,EAAS,IAAW,EACtB,MAAO,CACL,GAAI,EACJ,GAAI,EACJ,EAAG,GAGP,GAAM,GAAiB,KAAK,IAAI,EAAQ,EAAS,GAAK,EAAS,IACzD,EAAoB,EAAmB,GACvC,EAAoB,EAAmB,GAEvC,EAAW,CACf,EAAG,EAAO,EAAI,EAAkB,EAAI,EACpC,EAAG,EAAO,EAAI,EAAkB,EAAI,GAEhC,EAAW,CACf,EAAG,EAAO,EAAI,EAAkB,EAAI,EACpC,EAAG,EAAO,EAAI,EAAkB,EAAI,GAQtC,MANa,CACX,GAAI,EACJ,GAAI,EACJ,EAAG,IAMA,WAAoB,EAAW,EAAe,EAAoB,CACvE,MAAO,CACJ,GAAG,IAAM,EAAO,GAAK,EAAG,IAAM,EAAO,GACrC,EAAG,IAAM,EAAO,GAAK,EAAG,IAAM,EAAO,GCrZnC,WAA8B,CAU5B,QAAS,CACd,GAAM,CAAE,MAAK,OAAM,SAAQ,QAAO,QAAO,SAAQ,IAAG,KAAM,KAC1D,MAAO,CAAE,MAAK,OAAM,SAAQ,QAAO,QAAO,SAAQ,IAAG,KAKvD,YAAY,EAAoC,CAC9C,GAAI,MAAM,QAAQ,GAAO,CACvB,GAAM,GAAO,KAAK,IAAI,EAAK,GAAG,EAAG,EAAK,GAAG,GACnC,EAAQ,KAAK,IAAI,EAAK,GAAG,EAAG,EAAK,GAAG,GAAK,EACzC,EAAO,KAAK,IAAI,EAAK,GAAG,EAAG,EAAK,GAAG,GACnC,EAAS,KAAK,IAAI,EAAK,GAAG,EAAG,EAAK,GAAG,GAAK,EAChD,KAAK,IAAM,EACX,KAAK,KAAO,EACZ,KAAK,MAAQ,EACb,KAAK,MAAQ,KAAK,KAAO,KAAK,MAC9B,KAAK,OAAS,EACd,KAAK,OAAS,KAAK,IAAM,KAAK,OAC9B,KAAK,EAAI,KAAK,KACd,KAAK,EAAI,KAAK,QAEd,MAAK,IACH,OAAS,GACL,EAAK,IACL,KAAO,GACP,EAAK,EACL,EAAK,OAAS,EAAK,OACzB,KAAK,KACH,QAAU,GACN,EAAK,KACL,KAAO,GACP,EAAK,EACL,EAAK,MAAQ,EAAK,MACxB,KAAK,OAAS,UAAY,GAAO,EAAK,OAAS,KAAK,IAAM,EAAK,OAC/D,KAAK,MAAQ,SAAW,GAAO,EAAK,MAAQ,KAAK,KAAO,EAAK,MAC7D,KAAK,MAAQ,KAAK,MAAQ,KAAK,KAC/B,KAAK,OAAS,KAAK,OAAS,KAAK,IACjC,KAAK,EAAI,KAAK,KACd,KAAK,EAAI,KAAK,IAIX,MAAM,EAAW,EAAW,EAAmC,CACpE,GAAM,GAAe,GAAE,EAAG,EAAG,EAAG,GAAM,GAEtC,OAAQ,OACD,OACH,EAAM,EAAI,KAAK,KACf,UACG,QACH,EAAM,EAAI,KAAK,MACf,UAEG,SACH,EAAM,EAAI,KAAK,KAAO,KAAK,MAAQ,EACnC,cAEA,MAEJ,OAAQ,OACD,MACH,EAAM,EAAI,KAAK,IACf,UACG,SACH,EAAM,EAAI,KAAK,OACf,UAEG,SACH,EAAM,EAAI,KAAK,IAAM,KAAK,OAAS,EACnC,cAEA,MAGJ,MAAO,MAGE,SAAgB,CACzB,MAAO,CACL,EAAG,KAAK,KAAO,KAAK,MAAQ,EAC5B,EAAG,KAAK,IAAM,KAAK,OAAS,GAIzB,WAAW,EAAY,EAAiB,EAAc,CAC3D,OAAQ,OACD,OACH,MAAO,CAAE,KAAM,OAAQ,EAAG,KAAK,KAAO,EAAQ,EAAG,KAAK,OAAO,OAC1D,QACH,MAAO,CAAE,KAAM,QAAS,EAAG,KAAK,MAAQ,EAAQ,EAAG,KAAK,OAAO,OAC5D,MACH,MAAO,CAAE,KAAM,MAAO,EAAG,KAAK,OAAO,EAAG,EAAG,KAAK,IAAM,OACnD,SACH,MAAO,CAAE,KAAM,SAAU,EAAG,KAAK,OAAO,EAAG,EAAG,KAAK,OAAS,IAI3D,aAAa,EAAY,EAA4B,CAC1D,OAAQ,OACD,WACA,QACH,MAAO,CAAE,OAAM,EAAG,KAAK,GAAO,EAAG,KAAK,EAAI,KAAK,OAAS,OACrD,UACA,SACH,MAAO,CAAE,OAAM,EAAG,KAAK,EAAI,KAAK,MAAQ,EAAS,EAAG,KAAK,KAIxD,qBAAqB,EAAyC,CACnE,GAAM,CAAE,QAAS,EACjB,OAAQ,OACD,WACA,QAAS,CACZ,GAAM,GACJ,KAAK,SAAW,EAAI,GAAO,GAAU,EAAI,KAAK,GAAK,KAAK,OAC1D,MAAO,CAAE,OAAM,eAEZ,UACA,SAAU,CACb,GAAM,GACJ,KAAK,QAAU,EAAI,GAAO,GAAU,EAAI,KAAK,GAAK,KAAK,MAEzD,MAAO,CAAE,OAAM,aAKd,YAAY,EAAyB,CAC1C,OAAQ,OACD,OACH,MAAO,CACL,CAAE,EAAG,KAAK,KAAM,EAAG,KAAK,KACxB,CAAE,EAAG,KAAK,KAAM,EAAG,KAAK,aAEvB,QACH,MAAO,CACL,CAAE,EAAG,KAAK,MAAO,EAAG,KAAK,KACzB,CAAE,EAAG,KAAK,MAAO,EAAG,KAAK,aAExB,MACH,MAAO,CACL,CAAE,EAAG,KAAK,KAAM,EAAG,KAAK,KACxB,CAAE,EAAG,KAAK,MAAO,EAAG,KAAK,UAExB,SACH,MAAO,CACL,CAAE,EAAG,KAAK,KAAM,EAAG,KAAK,QACxB,CAAE,EAAG,KAAK,MAAO,EAAG,KAAK,iBAG3B,KAAM,IAAI,OAAM,iBAIf,OAAO,EAA6B,CACzC,MAAO,CACL,MACA,OACA,SACA,SACA,MAAM,AAAC,GACA,EAAU,KAAU,KAAK,IAI7B,UAAU,EAAY,EAAkB,CAC7C,MAAO,IAAI,GAAK,CACd,KAAM,KAAK,KAAO,EAClB,IAAK,KAAK,IAAM,EAChB,MAAO,KAAK,MACZ,OAAQ,KAAK,SAIV,OAAO,EAAoB,CAChC,MAAO,IAAI,GAAK,CACd,KAAM,EAAM,EACZ,IAAK,EAAM,EACX,MAAO,KAAK,MACZ,OAAQ,KAAK,SAIV,YAAY,EAAoB,EAAmB,EAAkB,CAC1E,MAAO,IAAI,GAAK,CACd,KAAM,KAAK,KAAO,EAClB,MAAO,KAAK,MAAQ,EACpB,IAAK,KAAK,IAAM,EAChB,OAAQ,KAAK,OAAS,IAInB,QAAc,CACnB,MAAO,CACL,CAAE,EAAG,KAAK,KAAM,EAAG,KAAK,KACxB,CAAE,EAAG,KAAK,MAAO,EAAG,KAAK,WC9N/B,GAAM,GAAQ,SAAS,gBAAgB,6BAA8B,OAErE,EAAM,aACJ,QACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAaF,GAAM,GAAQ,SAAS,gBAAgB,6BAA8B,QAErE,EAAM,UAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAclB,EAAM,YAAY,GAClB,SAAS,KAAK,YAAY,GAM1B,WAAkB,EAAS,EAA0B,CACnD,GAAM,GAAiB,GAAI,gBAAe,IAAM,CAC9C,sBAAsB,IAAM,CAC1B,AAAI,EAAG,cAAc,SAAS,IAC5B,EAAG,EAAG,6BAIZ,SAAe,QAAQ,GAEhB,IAAM,EAAe,UAAU,GAGxC,WAAkB,EA2BJ,CA3Fd,MA4FE,GAAM,GAAiB,GACrB,OAAQ,IACL,GAGC,CAAE,SAAQ,UAAW,EAE3B,YAAoB,CAnGtB,UAoGI,GAAM,GAAU,GAAI,GAAK,EAAM,yBAEzB,EAAa,GAAI,GAAK,EAAO,yBAC7B,EAAa,GAAI,GAAK,EAAO,yBAC7B,EAAa,EAAW,aAC5B,EAAe,WACf,KAAe,iBAAf,OAAiC,IAE/B,EAAW,EAAW,aACxB,EAAe,WACf,KAAe,iBAAf,OAAiC,IAGnC,AACE,EAAa,EAAe,cAAgB,EAAe,YAC3D,EAAe,iBAAmB,QAElC,CACE,CAAC,MAAO,UAAU,SAAS,EAAe,aAC1C,EAAW,EAAI,EAAW,MAC1B,EAAW,EAAI,EAAW,MAE1B,EAAS,EAAI,EAAW,EAExB,EAAW,EAAI,EAAW,KAC1B,EAAW,EAAI,EAAW,QAE1B,GAAS,EAAI,EAAW,IAG5B,EAAW,GAAK,EAAQ,IACxB,EAAS,GAAK,EAAQ,IACtB,GAAM,GAAQ,EACZ,EACA,EACA,KAAe,eAAf,OAA+B,IAE3B,EAAe,EACnB,EACA,EACA,GAGI,EAAU,EACd,EAAa,gBACb,EACA,GAKF,MAFc,GAAQ,EAAS,EAAS,EAAe,SAKzD,GAAM,GAAS,SAAS,gBAAgB,6BAA8B,QAEtE,EAAO,aAAa,SAAU,KAAe,QAAf,OAAwB,SACtD,EAAO,aAAa,eAAgB,KACpC,EAAO,aAAa,OAAQ,QAC5B,EAAO,aAAa,IAAK,KACzB,EAAO,aAAa,aAAc,eAE9B,EAAe,YACjB,OAAO,QAAQ,EAAe,YAAY,QAAQ,CAAC,CAAC,EAAK,KAAW,CAClE,EAAO,aAAa,EAAK,KAG7B,EAAM,YAAY,GAElB,GAAM,GAAM,CACV,OAAQ,IAAM,CACZ,EAAO,aAAa,IAAK,OAI7B,SAAS,EAAQ,EAAI,QACrB,EAAS,EAAQ,EAAI,QAEd,EAGT,WAA6B,EAAqC,CAChE,MAAO,KAAW,OAAY,CAAC,EAAS,OAG1C,GAAM,GAAU,SAAS,iBAA8B,sBACjD,EAAqB,GAE3B,EAAQ,QAAQ,AAAC,GAAW,CA5L5B,QA6LE,GAAM,GAAS,EAAO,QAAQ,WAE9B,GAAI,CAAC,EACH,OAGF,GAAM,GAAW,SAAS,cAAc,sBAAsB,OAE9D,GAAI,CAAC,EACH,OAGF,GAAM,GAAc,KAAO,QAAQ,iBAAf,OAA0C,SACxD,EAAc,KAAO,QAAQ,iBAAf,OAA0C,MACxD,EAAiB,EAAoB,EAAO,QAAQ,oBACpD,EAAiB,EAAoB,EAAO,QAAQ,oBACpD,EAAe,EAAoB,EAAO,QAAQ,kBAExD,EAAM,KACJ,EAAS,CACP,OAAQ,EACR,aACA,iBACA,OAAQ,EACR,aACA,iBACA,eACA,WAAY,CACV,MAAO,QAET,OAAQ,QAKd,OAAO,iBAAiB,SAAU,IAAM,CACtC,EAAM,QAAQ,AAAC,GAAS,EAAK,YAG/B,EAAS,SAAS,KAAM,IAAM,CAC5B,EAAM,QAAQ,AAAC,GAAS,EAAK",
  "names": []
}
