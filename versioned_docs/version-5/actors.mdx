---
title: 'Actors'
---

import ThemedImage from '@theme/ThemedImage';

When you run a statechart, it becomes an actor: a running process that can receive messages, send messages and change its behavior based on the messages it receives, which can cause effects outside of the actor.

An invoked actor is an actor that can execute its own actions and communicate with the machine. These invoked actors are started in a state and stopped when the state is exited.

:::tip

Watch our [“What are invoked actors?” video on YouTube](https://www.youtube.com/watch?v=TRMS8NYKWnA&list=PLvWgkXBB3dd4I_l-djWVU2UGPyBgKfnTQ&index=9) (1m57s).

:::

## Using actors in the Studio

Invoked actors are are labeled on their invoking state with “Invoke /” followed by the actor’s source name and ID.

You can invoke multiple actors on a single state. Top-level final states cannot have invoked actors.

<p>
  <ThemedImage
    alt="Video player state machine containing closed and opened states. On the Play event, the Closed state transitions to the Opened state. The Opened state invokes a startVideo actor and has a description of “The video player should be in full-screen mode.” The Opened state contains Playing and Paused states, which are transitioned between using the Pause and Play events. There’s a Stop event from the Opened state that transitions to the final state of Stopped. There’s a delayed transition from the Stopped state back to the Closed state after 5 seconds."
    sources={{
      light:
        'https://stately.ai/registry/machines/66f77051-089e-4b0a-9fa9-42e1f7598135.light.png',
      dark: 'https://stately.ai/registry/machines/66f77051-089e-4b0a-9fa9-42e1f7598135.dark.png',
    }}
  />
</p>

[View this machine in the Stately Studio](https://stately.ai/registry/editor/e13bef2b-bb13-4465-96ac-0bc25340688e?machineId=66f77051-089e-4b0a-9fa9-42e1f7598135).

In the video player above, the *startVideo* actor is invoked when the video player is in the *Opened* state.

### Invoke actors on a state

1. Select the state you want to invoke an actor.
2. Open the **State details** panel from the right tool menu.
3. Use the **+** plus icon alongside the **Invoked actors** to add a new action.
4. Add the source for the actor using the **src** text input.
5. Add the ID for the actor using the **ID** text input.
6. Save the invoked actor using the **Save** button.

## Actor model

In the actor model, actors are objects that can talk to each other. They are independent computational entities that communicate via asynchronous message passing (XState refers to these messages as "events").

- An actor has its own internal, encapsulated state that can only be updated by the actor itself. An actor may choose to update its internal state in response to a message it receives, but it cannot be updated by any other entity.
- Actors communicate with other actors by sending and receiving events asynchronously.
- Actors process one message at a time. They have an internal "mailbox" that acts like an event queue, processing events one at a time.
- State is not shared between actors. The only way for an actor to share data is by sending events.
- Actors can spawn new actors.

## Stately Editor: actors

## Creating actors

- `interpret(machine, options)`
- Starting actors via `actor.start()`
- Stopping system actor via `actor.stop()`

Inside machines:

- invoke (link)
- spawn (link)

## Actor snapshots

- `actor.getSnapshot()`

## Subscribing to actors

- Subscribes to emitted actor snapshots

- `actor.subscribe(observer)`
- Plain function `(state) => { ... }`
- Observer `({ next, error, complete }) => { ... }`
- `subscription.unsubscribe()` for cleanup

## Initializing actor state

- `interpret(machine, { state }).start()`
- Link to persistence

## Awaiting actors

- `await waitFor(actor, selector)`

## State machine actors

- `createMachine({ ... })`

## Promise actors

- `fromPromise(() => new Promise(...))`

## Transition actors

- `fromTransition((state, event) => { ... }, initialState)`

## Observable actors

- `fromObservable(() => someObservable)`

## Event observable actors

- `fromEventObservable(() => someEventObservable)`

## Callback actors

- `fromCallback((sendBack, receive) => { ... })`

## Higher-level actor logic

```ts
function withUndoRedo(actorLogic) {
  return {
    ...actorLogic,
  };
}
```

## Custom actors

## TypeScript

## Cheatsheet

## Resources
