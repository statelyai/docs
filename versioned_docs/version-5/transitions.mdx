---
title: Events and transitions
---

import ThemedImage from '@theme/ThemedImage';
import useBaseUrl from '@docusaurus/useBaseUrl';

A **transition** is a change from one finite state to another, triggered by an event.

An **event** is a signal, trigger, or message that causes a transition. When an actor receives an event, its machine will determine if there are any enabled transitions for that event in the current state. If enabled transitions exist, the machine will take them and execute their actions.

Transitions are â€œdeterministicâ€; each combination of state and event always points to the same next state.

<p>
  <ThemedImage
    alt="A video player state machine with an initial Paused State and a Playing state. The Play event transitions from Paused to Playing. The Pause event transitions from Playing to Paused."
    sources={{
      light: useBaseUrl(
        '/transitions-and-events/intro/transitions-and-events.png'
      ),
      dark: useBaseUrl(
        '/transitions-and-events/intro/transitions-and-events-dm.png'
      ),
    }}
  />
</p>

[View this machine in Stately Studio](https://stately.ai/registry/editor/e13bef2b-bb13-4465-96ac-0bc25340688e?machineId=9630e3b7-9f8e-4dc9-8b55-661f854d28b7).

TODO: example going from form to closed

When a state machine receives an event, it only checks the active finite states to see if any of them have a transition for that event. Those transitions are called **enabled transitions**. If there is an enabled transition, the state machine will execute the transitionâ€™s actions and then transition to the target state.

Transitions are represented by `on:` in a state:

TODO: full feedback example


<details>
<summary>
Using transitions and events in Stately Studio
</summary>

The arrows are transitions, and the rounded rectangles on the arrowâ€™s lines are events. Each transition has aÂ **source**Â state which comes before the transition, and aÂ **target**Â state, which comes after the transition. The transitionâ€™s arrow starts from the source state and points to the target state.

:::tip

Watch our [â€œTransitions and eventsâ€ video on YouTube](https://www.youtube.com/watch?v=0qgP4RZyq58&list=PLvWgkXBB3dd4I_l-djWVU2UGPyBgKfnTQ&index=4) (1m50s).

:::

The arrows are transitions, and the rounded rectangles on the arrowâ€™s lines are events. Each transition has aÂ **source**Â state which comes before the transition, and aÂ **target**Â state, which comes after the transition. The transitionâ€™s arrow starts from the source state and points to the target state.

In the video player machine above, the events areÂ *PLAY*Â andÂ *PAUSE*. TheÂ *Play*Â event transitions from theÂ *Paused*Â state to theÂ *Playing*Â state. TheÂ *Pause*Â event transitions from theÂ *Playing*Â state to theÂ *Paused*Â state.

### Add a transition and event

1. Select an existing state.
2. Drag from the handles on the left, right and bottom sides of the selected state, and release to create a connecting transition, event and new state.

### Change the source and target states for a transition or event

First select the transition or event you want to change. Thenâ€¦

#### Using theÂ **Transition details**Â panel

1. Select the transition or event you wish to change.
2. Open theÂ **Transition details**Â panel from the right tool menu.
3. Choose a new source state from theÂ **Source**Â dropdown options.
4. Choose a new target state from theÂ **Target**Â dropdown options.

#### Dragging the transition handles

1. Select the transition or event you want to change.
2. Drag the transitionâ€™s handle connected to the source state to connect it to a new source state.
3. Drag the transitionâ€™s handle connected to the target state to connect it to a new target state.

### Switch the source and target states for a transition or event

1. Select the transition or event.
2. Right-click the state to bring up theÂ **quick actions**Â menu.
3. ChooseÂ **Switch source and target**Â from theÂ **quick actions**Â menu.

</details>

## Event objects

In XState, events are represented by event objects with a `type` property and optional payload:

- The `type` property is a string that represents the event type. 
- The payload is an object that contains additional data about the event.

```ts
feedbackMachine.send({
  // The event type
  type: 'feedback.update',
  // Additional payload
  feedback: 'This is great!',
  rating: 5,
});
```

## Selecting transitions

- Start on deepest active state nodes (aka atomic states)
- If transition is enabled (guard passes), take it
- If no transition is enabled, go up to its parent state and repeat
- If no transitions are enabled, no transitions will be taken, state remains the same

## Self-transitions

A state can transition to itself. This is known as a **self-transition**, and is useful for changing context and/or executing actions without changing the finite state. You can also use self-transitions to restart a state.

TODO: Why you might use self-transitions with example.

### Using self-transitions in Stately Studio

#### Make an event into a self-transition

##### Using theÂ **quick actions**Â menu

1. Right-click the event to bring up theÂ **quick actions**Â menu.
2. ChooseÂ **Make self transition**Â from theÂ **quick actions**Â menu.

##### Dragging the transition arrow

1. Select the event.
2. Grab the circular handle at the arrow end of the transition and drag the handle to connect it back to the source state.

TODO: assign example

## Transitions between states

Typically, transitions are between two sibling states.

TODO: example with `{ on: { target: 'sibling' } }`

## Parent to child transitions

When a state machine receives an event, it will first check the deepest ([atomic](state-machines-and-statecharts.mdx#atomic-states)) state to see if there is any enabled transition. If not, the parent state is checked, and so on, until the machine reaches the root state.

When you want an event to transition to a state regardless of which sibling state is active, a useful pattern is to transition from the parent state to the child state.

TODO: example with `{ on: { target: '.child' } }`

## Re-entering

By default, when a state machine transitions from a parent state to the same parent state or a descendent (child or deeper), it will not re-enter the parent state; that is, it will not execute the [`exit` and `entry` actions](actions.mdx) of the parent state.

If you want the parent state to be re-entered, you can set the `reenter` property to `true`. This will cause the parent state to re-enter, executing the `exit` and `entry` actions of the parent state.

:::tip

In XState v4, re-entering transitions were known as **external transitions**, and the default transitions were known as **internal transitions**.

:::

TODO: illustration showing no re-enter vs. re-enter

TODO: example with `{ target: '.child', reenter: true }`

## Transitions to any state

Sibling descendent states: `{ target: 'sibling.child.grandchild' }`

Parent to descendent states: `{ target: '.child.grandchild' }`

State to any state: `{ target: '#specificState' }`

## Forbidden transitions

- `{ on: { forbidden: {} } }`
- Different than omitting the transition; transition selection algorithm will stop looking
- Same as `{ on: { forbidden: { target: undefined } } }`

## Wildcard transitions

A wildcard transition is a transition that will match any event. The event descriptor (key of the `on: {...}` object) is defined using the `*` wildcard character as the event type:

```ts
import { createMachine } from 'xstate';

const feedbackMachine = createMachine({
  initial: 'asleep',
  states: {
    asleep: {
      on: {
        // highlight-start
        // This transition will match any event
        '*': { target: 'awake' },
        // highlight-end
      },
    },
    awake: {},
  },
});
```

Wildcard transitions are useful for:
- handling events that are not handled by any other transition.
- as a â€œcatch-allâ€ transition that handles any event in a state. 

A wildcard transition has the least priority; it will only be taken if no other transitions are enabled.

## Partial wildcard transitions

A partial wildcard transition is a transition that matches any event that starts with a specific prefix. The event descriptor is defined by using the wildcard character (`*`) after a dot (`.`) as the event type:

```ts
import { createMachine } from 'xstate';

const feedbackMachine = createMachine({
  initial: 'prompt',
  states: {
    prompt: {
      on: {
        // highlight-start
        // This will match any event that starts with 'feedback.':
        // 'feedback.good', 'feedback.bad', etc.
        'feedback.*': { target: 'form' },
        // highlight-end
      },
    },
    form: {},
    // ...
  },
});
```

The wildcard character (`*`) can only be used in the suffix of an event descriptor, following a dot (`.`):

### Valid wildcard examples

- âœ… `mouse.*`: matches `mouse.click`, `mouse.move`, etc.
- âœ… `mouse.click.*`: matches `mouse.click.left`, `mouse.click.right`, etc.

### Invalid wildcard

- ğŸš« ~~`mouse*`~~: invalid; does not match any event.
- ğŸš« ~~`mouse.*.click`~~: invalid; `*` cannot be used in the middle of an event descriptor.
- ğŸš« ~~`*.click`~~: invalid; `*` cannot be used in the prefix of an event descriptor.
- ğŸš« ~~`mouse.click*`~~: invalid; does not match any event.
- ğŸš« ~~`mouse.*.*`~~: invalid; `*` cannot be used in the middle of an event descriptor.

## Multiple transitions in parallel states

- Advanced topic
- `target: ['.mode.inactive', '.status.disabled']`

## Other transitions

- [Eventless (always) transitions](eventless-transitions.mdx) are transitions without events. These transitions areÂ *always*Â taken after any transition in their state is enabled.
- [Delayed (after) transitions](delayed-transitions.mdx) are transitions that only happen after a specified interval of time.

## Transition descriptions

You can add `.description` to transitions to describe their purpose and share related notes with your team. Stately Studioâ€™s editor renders these descriptions in the machine and supports markdown, including links, images, and lists. [Read more about descriptions in Stately Studio](descriptions.mdx).

```ts

"MOVE TO PROJECT": {
  target: "#MoveModal Machine.Closed",
  actions: "moveToProject",
  // highlight-start
  description:
    "`moveToProject` requests to move a machine to a different project using the `editorPageMachine`.",
  // highlight-end
},

```

## Shorthands

If the transition only specifies a `target`, then the string target can be used as a shorthand instead of the entire transition object:

```ts
import { createMachine } from 'xstate';

const feedbackMachine = createMachine({
  initial: 'prompt',
  states: {
    prompt: {
      on: {
        // highlight-start
        // This is shorthand for:
        // 'feedback': { target: 'form' }
        'feedback.good': 'thanks',
        // highlight-end
      },
    },
    thanks: {},
    // ...
  },
});
```

Using the string target shorthand is useful for quickly prototyping state machines. Generally, we recommended using the full transition object syntax as it will be consistent with all other transition objects and will be easier to add actions, guards, and other properties to the transition in the future.

## TypeScript

## Cheatsheet

## Resources
