---
title: 'State machines'
---

A [state machine](state-machines-and-statecharts.mdx) is a model that describes how the state of an [actor](actors.mdx) transitions to another state when an event occurs.

:::tip

Read our [introduction to state machines and statecharts](state-machines-and-statecharts.mdx) if you haven’t already!

:::

## Benefits of state machines

State machines help build reliable and robust software:

- Use state machines to implement complex state-based logic in a modular and efficient way.
- You can easily extend and modify state machines as your system’s requirements change over time.
- State machines provide a clear and concise representation of complex behavior, making it easier for you to reason about and understand code.
- State machines help avoid errors and bugs in code by making it easier to prevent impossible states and undesired transitions.
- You can use state machines to model the behavior of real-world systems, making it easier to test and debug software.

## Creating a state machine

In [XState](xstate.mdx), a state machine (referred to as a “machine”) is created using the `createMachine(config)` function:

```ts
import { createMachine } from 'xstate';

const feedbackMachine = createMachine({
  id: 'feedback',
  initial: 'question',
  states: {
    question: {
      on: {
        'feedback.good': {
          target: 'thanks',
        },
      },
    },
    thanks: {
      // ...
    },
    // ...
  },
});
```

## Interpreting machines

A machine is just a blueprint for an actor. An [actor](actors.mdx) is a running instance of the machine; in other words, it is the entity whose logic is described by the machine.

To create an actor, interpret the machine using the `interpret(machine)` function:

```ts
import { interpret } from 'xstate';

const feedbackActor = interpret(feedbackMachine);

feedbackActor.subscribe((state) => {
  console.log(state.value);
});

feedbackActor.start();
// logs 'question'
```

## Providing implementations

Machine implementations are the language-specific code that is executed but is not directly related to the state machine’s logic. This includes:

- [Actions](actions.mdx)
- [Actors](actors.mdx)
- [Guards](guards.mdx)
- [Delays](delayed-transitions.mdx)

Typically, you will reference implementations using strings or objects, such as `{ type: 'doSomething' }`, and then create a new machine with the provided implementations using `machine.provide({...})`:

```ts
import { createMachine } from 'xstate';

const feedbackMachine = createMachine({
  // ...
});

const feedbackMachineWithImpls = feedbackMachine.provide({
  actions: {
    /* ... */
  },
  actors: {
    /* ... */
  },
  guards: {
    /* ... */
  },
  delays: {
    /* ... */
  },
});
```

Those references are then resolved to the actual provided implementation:

```ts
const feedbackMachine = createMachine({
  entry: { type: 'doSomething' },
  // ...
});

const feedbackActor = interpret(
  feedbackMachine.provide({
    actions: {
      doSomething: () => {
        console.log('Doing something!');
      },
    },
  })
).start();

// logs 'Doing something!'
```

## Specifying types

You can specify TypeScript types inside the machine config using the `.types` property:

```ts
const feedbackMachine = createMachine({
  types: {} as {
    context: { feedback: string };
    events: { type: 'feedback.good' } | { type: 'feedback.bad' };
    actions: { type: 'logTelemetry' };
  },
});
```

These types will be inferred throughout the machine config and in the created machine and actor so that methods such as `machine.transition(...)` and `actor.send(...)` will be type-safe.

## Transition method

A machine’s `.transition(state, event)` method is a pure method that returns the next state given the current state and an event:

```ts
const feedbackMachine = createMachine({
  initial: 'question',
  states: {
    question: {
      on: {
        'feedback.good': {
          target: 'thanks',
        },
      },
    },
    thanks: {
      // ...
    },
    // ...
  },
});

const { initialState } = feedbackMachine;

const nextState = feedbackMachine.transition(initialState, {
  type: 'feedback.good',
});
```

The `machine.transition(...)` method is useful for testing or building a custom interpreter.

## API

TODO: Link to API

## TypeScript

TODO:

## Machine cheatsheet

Use our XState machine cheatsheet below to get started quickly.

### Create a machine

```ts
import { createMachine } from 'xstate';

const machine = createMachine({
  initial: 'start',
  states: {
    start: {},
    // ...
  },
});
```

### Provide implementations

```ts
import { createMachine } from 'xstate';

const machine = createMachine({
  // ...
});

const machineWithImpls = machine.provide({
  actions: {
    /* ... */
  },
  actors: {
    /* ... */
  },
  guards: {
    /* ... */
  },
  delays: {
    /* ... */
  },
});
```

### Further resources

TODO:
