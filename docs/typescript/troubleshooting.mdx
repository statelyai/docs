---
title: TypeScript Troubleshooting
---

<!-- deps: ["context-typescript", "events-typescript"] -->

There are some known limitations with XState and TypeScript. We love TypeScript, and we’re _constantly_ pressing ahead to make it a better experience in XState.

Here are some known issues, all of which have workarounds:

### Events in machine options

When you use `createMachine`, you can pass in implementations to named actions, actors and guards in your config. For example:

```ts twoslash
// @errors: 2339
import { createMachine } from 'xstate';

interface Context {}

type Event =
  | { type: 'EVENT_WITH_FLAG'; flag: boolean }
  | {
      type: 'EVENT_WITHOUT_FLAG';
    };

createMachine(
  {
    schema: {
      context: {} as Context,
      events: {} as Event,
    },
    on: {
      EVENT_WITH_FLAG: {
        actions: 'consoleLogData',
      },
    },
  },
  {
    actions: {
      consoleLogData: (context, event) => {
        // This will error at .flag
        console.log(event.flag);
      },
    },
  }
);
```

The example above errors because inside the `consoleLogData` function, XState doesn’t know which event caused it to fire. The cleanest way to manage this issue is to assert the event type yourself:

```ts twoslash
import { createMachine } from 'xstate';

interface Context {}

type Event =
  | { type: 'EVENT_WITH_FLAG'; flag: boolean }
  | {
      type: 'EVENT_WITHOUT_FLAG';
    };

const config = {
  schema: {
    context: {} as Context,
    events: {} as Event,
  },
  on: {
    EVENT_WITH_FLAG: {
      actions: 'consoleLogData',
    },
  },
};

// ---cut---

createMachine(config, {
  actions: {
    consoleLogData: (context, event) => {
      if (event.type !== 'EVENT_WITH_FLAG') return;
      console.log(event.flag);
      //                ^?
    },
  },
});
```

Sometimes it’s also possible to move the implementation inline.

<!-- TODO - remove the noErrors tag below when https://github.com/statelyai/xstate/pull/3217 is fixed-->

```ts twoslash
// @noErrors
import { createMachine } from 'xstate';
interface Context {}

type Event =
  | { type: 'EVENT_WITH_FLAG'; flag: boolean }
  | {
      type: 'EVENT_WITHOUT_FLAG';
    };

// ---cut---

createMachine({
  schema: {
    context: {} as Context,
    events: {} as Event,
  },
  on: {
    EVENT_WITH_FLAG: {
      actions: (context, event) => {
        console.log(event.flag);
        //                ^?
      },
    },
  },
});
```

Moving the implementation inline doesn’t work for all cases. The action loses its name, making it uglier in the visualizer. And if the action is duplicated in several places, you’ll need to copy-paste it to all the required locations.

### Event types in entry actions

Event types in inline entry actions are not currently typed to the event that led to them. Consider the following example:

```ts twoslash
// @errors: 2339
import { createMachine } from 'xstate';

interface Context {}

type Event =
  | { type: 'EVENT_WITH_FLAG'; flag: boolean }
  | {
      type: 'EVENT_WITHOUT_FLAG';
    };

createMachine({
  schema: {
    context: {} as Context,
    events: {} as Event,
  },
  initial: 'state1',
  states: {
    state1: {
      on: {
        EVENT_WITH_FLAG: {
          target: 'state2',
        },
      },
    },
    state2: {
      entry: [
        (context, event) => {
          console.log(event.flag);
        },
      ],
    },
  },
});
```

In the example above, XState doesn’t know which event led to the `entry` action on `state2`. The only fix similar to the fix for events in machine options above:

```ts twoslash {19-20}
import { createMachine } from 'xstate';

interface Context {}

type Event =
  | { type: 'EVENT_WITH_FLAG'; flag: boolean }
  | {
      type: 'EVENT_WITHOUT_FLAG';
    };

// ---cut---

createMachine({
  schema: {
    context: {} as Context,
    events: {} as Event,
  },
  initial: 'state1',
  states: {
    state1: {
      on: {
        EVENT_WITH_FLAG: {
          target: 'state2',
        },
      },
    },
    state2: {
      entry: [
        (context, event) => {
          if (event.type !== 'EVENT_WITH_FLAG') return;
          console.log(event.flag);
          //                ^?
        },
      ],
    },
  },
});
```

### Assign action behaving strangely

<!-- TODO - rewrite this assign section when we figure out what's happening with the mixed syntax below-->

When run in `strict: true` mode, assign actions can sometimes behave strangely.

```ts twoslash
import { createMachine, assign } from 'xstate';
// ---cut---

interface Context {
  something: boolean;
  skip: boolean;
}

createMachine({
  schema: {
    context: {} as Context,
  },
  entry: [
    assign({
      skip: true,
      something: (context) => context.something,
      //                               ^?
    }),
  ],
});
```

In this case, it may appear that nothing you try works and all syntaxes seem buggy. The fix is strange but works consistently: add an unused `context` argument to the first argument of your assigner function.

```ts twoslash
// @noErrors
import { createMachine, assign } from 'xstate';

interface Context {
  something: boolean;
  skip: boolean;
}
// ---cut---

createMachine({
  schema: {
    context: {} as Context,
  },
  entry: [
    assign({
      skip: (context) => true,
      something: (context) => context.something,
      //                               ^?
    }),
  ],
});
```

The assign action issue is a nasty bug to fix and involves moving our codebase to strict mode, which we have planned for XState V5.

### `keyofStringsOnly`

If you are seeing the following error:

```

Type error: Type 'string | number' does not satisfy the constraint 'string'.
Type 'number' is not assignable to type 'string'. TS2344

```

Ensure that your tsconfig file does not include `"keyofStringsOnly": true,`.
